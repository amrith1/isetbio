function synthesizedRFParams = synthesizeRetinalRFparamsConsistentWithVisualRFparams(obj, ...
    rfCenterInputConesNum, rfCenterPositionMicrons, deconvolutionOpticsParams)
% Returns a struct with corresponding retinal <-> visual parameter of
% center/surround characteristic radii & peak sensitivities. These
% are computed from the retinal RF center size and position as determined
% by the connectivity matrix between the cone mosaic and the mRGC RF
% mosaic. The correspondence between retinal <-> visual parameters is build
% based on a deconvolution model (computed based on the various deconvolution files
% which are generated via obj.generatePolansOpticsDeconvolutionFiles()).
% 
    % Validate deconvolutionOpticsParams
    obj.validateDeconvolutionOpticsParams(deconvolutionOpticsParams);
    
    % Compute the deconvolution model. This relies on the various
    % ecc_-%2.1f_deconvolutions_refractionError_%2.2fD.mat data files that
    % are generated by obj.generatePolansOpticsDeconvolutionFiles(deconvolutionOpticsParams)
    % See performPSFConvoComputations
    deconvolutionModel = obj.computeDeconvolutionModel(deconvolutionOpticsParams);
    
    % Convert RF center positions in retinal microns to visual degs
    rfEccRadiusMicrons = (sqrt(sum(rfCenterPositionMicrons.^2,2.0)))';
    rfEccRadiusDegs = WatsonRGCModel.rhoMMsToDegs(rfEccRadiusMicrons/1000.0);
    
    rgcsNum = numel(rfCenterInputConesNum);
    centerVisualCharacteristicRadiiDegs = zeros(1, rgcsNum);

    targetEccIndices = zeros(rgcsNum,2);
    eccWeights = zeros(rgcsNum,2);
    
    for RGCindex = 1:rgcsNum
        % Determine the deconvolution model's closest 2 eccentricities to
        % this cell's eccentricity. We interpolate deconvolution model params from these 2 eccentricities.
        [~,idx] = sort(abs(deconvolutionModel.center.tabulatedEccentricities-rfEccRadiusDegs(RGCindex)), 'ascend');
        targetEccIndices(RGCindex,1:2) = idx(1:2);
        closestEccs = deconvolutionModel.center.tabulatedEccentricities(targetEccIndices(RGCindex,:));
        eccDiffs = abs(closestEccs-rfEccRadiusDegs(RGCindex));
        % Interpolation weights
        eccWeights(RGCindex,1) = eccDiffs(2)/sum(eccDiffs);
        eccWeights(RGCindex,2) = eccDiffs(1)/sum(eccDiffs);
    end
    
    % Use the deconvolutionModel.center to determine the center's VISUAL characteristic radius
    % based on the number of input cones to this cells' RF center
    parfor RGCindex = 1:rgcsNum
        centerVisualCharacteristicRadiiDegs(RGCindex) = ...
            eccWeights(RGCindex,1) * deconvolutionModel.center.visualCharacteristicRadius(targetEccIndices(RGCindex,1), rfCenterInputConesNum(RGCindex)) + ...
            eccWeights(RGCindex,2) * deconvolutionModel.center.visualCharacteristicRadius(targetEccIndices(RGCindex,2), rfCenterInputConesNum(RGCindex));
    end
    
    % Use the Croner&Kaplan model centerPeakSensitivityFunction() to
    % compute the center VISUAL peak sensitivity from the center's VISUAL
    % characteristic radius computed previously
    centerVisualPeakSensitivities = obj.centerPeakSensitivityFunction(...
        obj.centerPeakSensitivityParams, centerVisualCharacteristicRadiiDegs);
    
    % Use the deconvolutionModel.center to compute the sensitivity attenuation. Then we determine the 
    % center's RETINAL peak sensitivity, which is the center's VISUAL peak sensitivity x sensitivity attenuation
    parfor RGCindex = 1:rgcsNum
        peakSensitivityAttenuation(RGCindex) = ...
            eccWeights(RGCindex,1) * deconvolutionModel.center.visualGainAttenuation(targetEccIndices(RGCindex,1), rfCenterInputConesNum(RGCindex)) + ...
            eccWeights(RGCindex,2) * deconvolutionModel.center.visualGainAttenuation(targetEccIndices(RGCindex,2), rfCenterInputConesNum(RGCindex));
        %peakSensitivityAttenuation = 1;
        centerRetinalPeakSensitivities(RGCindex) = centerVisualPeakSensitivities(RGCindex) / peakSensitivityAttenuation(RGCindex);    
    end

    figure(567);
    subplot(1,2,1);
    plot(rfCenterInputConesNum, peakSensitivityAttenuation, 'ks');
    set(gca, 'XLim', [0 5], 'XTick', 0:1:10, 'YLim', [0 1], 'YTick', 0:0.1:1.0);
    xlabel('# of input cones');
    ylabel('visual sensitivity attenuation');
    
    subplot(1,2,2);
    plot(rfCenterInputConesNum, centerVisualCharacteristicRadiiDegs, 'ks');
    set(gca, 'XLim', [0 5], 'XTick', 0:1:10, 'YScale', 'log', 'YLim', [0.001 1], 'YTick', [0.001 0.003 0.01 0.03 0.1 0.3 1]);
    xlabel('# of input cones');
    ylabel('visual characteristic radius (degs)');
    pause
    
    % Use the Croner&Kaplan model center-to-surround ratio function to
    % compute the surround VISUAL characteristic radius 
    surroundVisualCharacteristicRadiiDegs = ...
        CronerKaplanRGCModel.surroundRadiusFromCenterRadiusDegs(centerVisualCharacteristicRadiiDegs);


    % Use the Croner&Kaplan model surround to center integrated
    % sensitivity ratio to compute the surround VISUAL peak sensitivity
    surroundVisualPeakSensitivities = ...
        CronerKaplanRGCModel.surroundToCenterIntegratedVisualSensitivityRatiosFromEccDegs(rfEccRadiusDegs) .* ...
        centerVisualPeakSensitivities ./ ...
        ((surroundVisualCharacteristicRadiiDegs./centerVisualCharacteristicRadiiDegs).^2);
    

    % NOW WE NEED THE SURROUND DECONVOLUTION MODEL TO COMPUTE the following:
    % surroundRetinalPeakSensitivities
    % surroundRetinalRadiiMicrons
    
    % FOR NOW et the surround params to their visual counterparts
    fprintf(2, 'setting surround retinal properties to their visual counterparts. Implement surround deconvolution\n'); 
    surroundRetinalPeakSensitivities = surroundVisualPeakSensitivities;
    surroundRetinalCharacteristicRadiiMicrons = 1e3 * WatsonRGCModel.rhoDegsToMMs(surroundVisualCharacteristicRadiiDegs);
    
    synthesizedRFParams = struct(...
        'rfEccRadiusDegs', rfEccRadiusDegs, ...                                                   % ecc of RGCs within the target patch  - DONE
        'rfCenterPositionMicrons', rfCenterPositionMicrons, ...
        'visual', struct(...                                                        % VISUAL RF properties
            'centerCharacteristicRadiiDegs', centerVisualCharacteristicRadiiDegs, ...             % - DONE
            'surroundCharacteristicRadiiDegs', surroundVisualCharacteristicRadiiDegs, ...         % - DONE
            'centerPeakSensitivities', centerVisualPeakSensitivities,...            % - DONE
            'surroundPeakSensitivities', surroundVisualPeakSensitivities...         % - DONE
            ), ...
         'retinal', struct(...                                                      % RETINAL RF properties
             'centerPeakSensitivities', centerRetinalPeakSensitivities,... 
             'surroundCharacteristicRadiiMicrons', surroundRetinalCharacteristicRadiiMicrons, ...
             'surroundPeakSensitivities', surroundRetinalPeakSensitivities... 
            )...
         );
    
end

function old
    surroundToCenterIntegratedSensitivitySigma = 0; % 0.3;
    surroundToCenterIntegratedSensitivityAtZeroEccentricity = 0.466;
    surroundToCenterIntegratedSensitivityIncreaseWithEccentricity = 0.007;
    surroundCenterRadiusRatioMean = 0.15;
    surroundCenterRadiusRatioStd = 0.00;
    
    cellsNum = numel(retinalCenterRadiiMicrons);
    
    % Convert RF center positions from retinal microns to visual degs
    retinalEccentricitiesMicrons = sqrt(sum(retinalCenterPositionMicrons.^2,2.0));
    retinalEccentricitiesDegs = (WatsonRGCModel.rhoMMsToDegs(retinalEccentricitiesMicrons/1000.0))';
    
    % Compute cone spacing and cone aperture radii in degrees at the eccentricities of the RF centers
    w = WatsonRGCModel();
    coneRFSpacingsDegs  = w.coneRFSpacingAndDensityAlongMeridian(retinalEccentricitiesDegs, ...
            'nasal meridian','deg', 'deg^2', ...
            'correctForMismatchInFovealConeDensityBetweenWatsonAndISETBio', false);
    coneApertureRadii = WatsonRGCModel.coneApertureToDiameterRatio * coneRFSpacingsDegs/2;
    
    
    % Convert RF center radii from retinal microns to visual degs
    retinalCenterRadii = WatsonRGCModel.sizeRetinalMicronsToSizeDegs(retinalCenterRadiiMicrons, retinalEccentricitiesMicrons);
    
    % Stats of surround/center radius
    surroundToCenterRadiusRatio = normrnd(surroundCenterRadiusRatioMean, surroundCenterRadiusRatioStd, [1 cellsNum]);
    
    % Preallocate memory
    visualCenterRadii = zeros(1, cellsNum);
    visualSurroundRadii = zeros(1, cellsNum);
    visualCenterPeakSensitivities = zeros(1, cellsNum);
    visualSurroundPeakSensitivities = zeros(1, cellsNum);
    visualSurroundToCenterIntegratedSensitivityRatio = zeros(1, cellsNum);
    
    retinalCenterRadii = reshape(retinalCenterRadii, [1 cellsNum]);
    retinalSurroundRadii = zeros(1, cellsNum);
    retinalSurroundRadiiMicrons = zeros(1, cellsNum);
    retinalCenterPeakSensitivities = zeros(1, cellsNum);
    retinalSurroundPeakSensitivities = zeros(1, cellsNum);
    retinalSurroundToCenterIntegratedSensitivityRatio = zeros(1, cellsNum);
    
    for cellIndex = 1:cellsNum
        % Cell eccentricity
        retinalEccDegs = retinalEccentricitiesDegs(cellIndex);
        
        % Determine the visual radius using the retinal radius and the deconvolution model
        [visualCenterRadii(cellIndex),closestEccIndices] = ...
            determineVisualRadius(coneApertureRadii(cellIndex)/3, retinalCenterRadii(cellIndex), retinalEccDegs, deconvolutionModel);
        
        % Determine the visual surround radius from the visual center radius and surround-to-center radius ratio
        visualSurroundRadii(cellIndex) = visualCenterRadii(cellIndex) / surroundToCenterRadiusRatio(cellIndex);
        
        % Determine the corresponding retinal surround radius (in degrees) from the visual surround radius and the deconvolution model
        retinalSurroundRadii(cellIndex) = determineRetinalRadius(visualSurroundRadii(cellIndex), retinalEccDegs, deconvolutionModel, closestEccIndices);
        
        % Retinal surround radius in microns
        retinalSurroundRadiiMicrons(cellIndex) = WatsonRGCModel.sizeDegsToSizeRetinalMicrons(retinalSurroundRadii(cellIndex), retinalEccDegs);
        
        % Compute visual peak sensitivity for center 
        visualCenterPeakSensitivities(cellIndex) = obj.centerPeakSensitivityFunction(obj.centerPeakSensitivityParams, visualCenterRadii(cellIndex));
       
        % Compute visual peak sensitivity for surround based on the stats of integrated sensitivity ratio in the visual data
        surroundToCenterIntegratedSensitivityMean = surroundToCenterIntegratedSensitivityAtZeroEccentricity  + ...
                                                    surroundToCenterIntegratedSensitivityIncreaseWithEccentricity * retinalEccDegs;
        surroundToCenterIntegratedSensitivityRatio = normrnd(surroundToCenterIntegratedSensitivityMean, surroundToCenterIntegratedSensitivitySigma);
        % Not less than 0.15 and not more than 0.85
        while (surroundToCenterIntegratedSensitivityRatio<0.2) || (surroundToCenterIntegratedSensitivityRatio>0.8)
            surroundToCenterIntegratedSensitivityRatio = normrnd(0.466 + 0.007*retinalEccDegs, surroundToCenterIntegratedSensitivitySigma);
        end
        visualSurroundPeakSensitivities(cellIndex) = surroundToCenterIntegratedSensitivityRatio * visualCenterPeakSensitivities(cellIndex) * (visualCenterRadii(cellIndex)/visualSurroundRadii(cellIndex))^2;
        
        visualSurroundToCenterIntegratedSensitivityRatio(cellIndex) = ...
            visualSurroundPeakSensitivities(cellIndex)/visualCenterPeakSensitivities(cellIndex) * ...
            (visualSurroundRadii(cellIndex)/visualCenterRadii(cellIndex))^2;
        
        % Determine corresponding retinal gain for center
        centerGainAttenuation = determineRetinalGainAttenuation(retinalCenterRadii(cellIndex), retinalEccDegs, deconvolutionModel, closestEccIndices);
        retinalCenterPeakSensitivities(cellIndex) = visualCenterPeakSensitivities(cellIndex) / centerGainAttenuation;
        
        % Determine corresponding retinal gain for surround
        surroundGainAttenuation = determineRetinalGainAttenuation(retinalSurroundRadii(cellIndex), retinalEccDegs, deconvolutionModel, closestEccIndices);
        
        % We need this bias in gain attenuation to get SF tuning curves with proper surround strengths
        centerBias = 0.65;
        surroundGainAttenuation = (1-centerBias)*surroundGainAttenuation+(centerBias)*centerGainAttenuation;
        
        retinalSurroundPeakSensitivities(cellIndex) = visualSurroundPeakSensitivities(cellIndex) / surroundGainAttenuation;
        
        retinalSurroundToCenterIntegratedSensitivityRatio(cellIndex) = ...
            retinalSurroundPeakSensitivities(cellIndex)/retinalCenterPeakSensitivities(cellIndex) * ...
            (retinalSurroundRadii(cellIndex)/retinalCenterRadii(cellIndex))^2;
        
    end % cellIndex
    
    synthesizedRFParams = struct(...
        'eccDegs', retinalEccentricitiesDegs, ...       % ecc of RGCs within the target patch
        'visual', struct(...                            % visual RF properties (assuming Polans PSFs)
            'centerRadiiDegs', visualCenterRadii, ...
            'surroundRadiiDegs', visualSurroundRadii, ...
            'centerPeakSensitivities', visualCenterPeakSensitivities,...
            'surroundPeakSensitivities', visualSurroundPeakSensitivities,...
            'surroundToCenterIntegratedSensitivityRatio', visualSurroundToCenterIntegratedSensitivityRatio ...
            ), ...
        'retinal', struct(...                          % retinal RF properties
            'centerRadiiMicrons', retinalCenterRadiiMicrons, ...
            'surroundRadiiMicrons', retinalSurroundRadiiMicrons, ...
            'centerRadiiDegs', retinalCenterRadii, ...
            'surroundRadiiDegs', retinalSurroundRadii, ...
            'centerPeakSensitivities', retinalCenterPeakSensitivities,...
            'surroundPeakSensitivities', retinalSurroundPeakSensitivities,...
            'surroundToCenterIntegratedSensitivityRatio', retinalSurroundToCenterIntegratedSensitivityRatio ...
            ) ...
        );

end

function retinalGainAttenuation = determineRetinalGainAttenuation(retinalRadius, retinalEccDegs, deconvolutionModel, closestEccIndices)
    % Compute ecc distances for the closest ecc
    d1 = abs(deconvolutionModel.tabulatedEccentricities(closestEccIndices(1))-retinalEccDegs);
    d2 = abs(deconvolutionModel.tabulatedEccentricities(closestEccIndices(2))-retinalEccDegs);
    
    % Compute attenuations for the 2 closest eccentricities
    gainAttenuation1 =  deconvolutionModel.modelFunctionGain(deconvolutionModel.fittedParamsGain(closestEccIndices(1),:), retinalRadius);
    gainAttenuation2 =  deconvolutionModel.modelFunctionGain(deconvolutionModel.fittedParamsGain(closestEccIndices(2),:), retinalRadius);
    
    % Compute weighted average of retinal gain attenuations
    retinalGainAttenuation = gainAttenuation1 * d2/(d1+d2) + gainAttenuation2 * d1/(d1+d2);
end


function retinalRadius =  determineRetinalRadius(visualRadius, retinalEccDegs, deconvolutionModel, closestEccIndices)
    % Compute ecc distances for the closest ecc
    d1 = abs(deconvolutionModel.tabulatedEccentricities(closestEccIndices(1))-retinalEccDegs);
    d2 = abs(deconvolutionModel.tabulatedEccentricities(closestEccIndices(2))-retinalEccDegs);
    
    % Compute retinal pooling radius functions for the 2 closest eccentricities
    retinalRadiusModel1 = deconvolutionModel.modelFunctionRadius(deconvolutionModel.fittedParamsRadius(closestEccIndices(1),:), visualRadius);
    retinalRadiusModel2 = deconvolutionModel.modelFunctionRadius(deconvolutionModel.fittedParamsRadius(closestEccIndices(2),:), visualRadius);
   
    % Compute weighted average of retinal radii
    retinalRadius = retinalRadiusModel1 * d2/(d1+d2) + retinalRadiusModel2 * d1/(d1+d2);
end


function [visualRadius, closestEccIndices] = determineVisualRadius(coneRadius, retinalRadius, retinalEccDegs, deconvolutionModel)
    % Find closest tabulated eccentricities to this cell's eccentricity
    [~,idx] = sort(abs(abs(deconvolutionModel.tabulatedEccentricities) - retinalEccDegs));
    d1 = abs(deconvolutionModel.tabulatedEccentricities(idx(1))-retinalEccDegs);
    d2 = abs(deconvolutionModel.tabulatedEccentricities(idx(2))-retinalEccDegs);
    closestEccIndices = idx(1:2);
    
    % Compute retinal pooling radius functions for a range of visual
    % radii (up to 10 x retinal radius) for the eccentricity closest to this cell's eccentricity
    visualRadiusSupport = linspace(retinalRadius, retinalRadius*10, 100);
    retinalPoolingRadiusModel1 = deconvolutionModel.modelFunctionRadius(deconvolutionModel.fittedParamsRadius(idx(1),:), visualRadiusSupport);
    retinalPoolingRadiusModel2 = deconvolutionModel.modelFunctionRadius(deconvolutionModel.fittedParamsRadius(idx(2),:), visualRadiusSupport);
        
    
    
    % Choose the visual center radius that corresponds to the model
    % retinal pooling radius that is closest to this cells center radius
    [~,index] = min(abs(retinalRadius-retinalPoolingRadiusModel1));
    visualRadius1 = visualRadiusSupport(index);
    [~,index] = min(abs(retinalRadius-retinalPoolingRadiusModel2));
    visualRadius2 = visualRadiusSupport(index);
    visualRadius = visualRadius1 * d2/(d1+d2) + visualRadius2 * d1/(d1+d2);
    
%     figure(500);
%     plot(visualRadiusSupport, retinalPoolingRadiusModel1, 'rs-'); hold on;
%     plot(visualRadiusSupport, retinalPoolingRadiusModel2, 'bs-'); hold on;
%     plot(visualRadiusSupport, visualRadiusSupport*0 + coneRadius, 'g-');
%     plot(visualRadius, retinalRadius, 'k*');
%     xlabel('visual radius (degs)');
%     ylabel('retinal radius (degs)')
%     set(gca, 'XLim', [0 max(visualRadiusSupport)], 'YLim', [0 max(visualRadiusSupport)]);
%     title(sprintf('Ecc: %2.3f degs',  retinalEccDegs));
%     axis 'square'
end

