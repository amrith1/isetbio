function synthesizedRFParams = synthesizeRetinalRFparamsConsistentWithVisualRFparams(obj, ...
    rfCenterInputConesNum, rfCenterPositionMicrons, deconvolutionOpticsParams)
% Returns a struct with corresponding retinal <-> visual parameter of
% center/surround characteristic radii & peak sensitivities. These
% are computed from the retinal RF center size and position as determined
% by the connectivity matrix between the cone mosaic and the mRGC RF
% mosaic. The correspondence between retinal <-> visual parameters is build
% based on a deconvolution model (computed based on the various deconvolution files
% which are generated via obj.generatePolansOpticsDeconvolutionFiles()).
% 
    % Validate deconvolutionOpticsParams
    obj.validateDeconvolutionOpticsParams(deconvolutionOpticsParams);
    
    % Compute the deconvolution model. This relies on the various
    % ecc_-%2.1f_deconvolutions_refractionError_%2.2fD.mat data files that
    % are generated by obj.generatePolansOpticsDeconvolutionFiles(deconvolutionOpticsParams)
    % See performPSFConvoComputations

    deconvolutionModel = obj.computeDeconvolutionModel(deconvolutionOpticsParams);

    % Convert RF center positions in retinal microns to visual degs
    rfEccRadiusMicrons = (sqrt(sum(rfCenterPositionMicrons.^2,2.0)));
    rfEccRadiusDegs = WatsonRGCModel.rhoMMsToDegs(rfEccRadiusMicrons/1000.0);
    
    % Find interpolation weights for the center deconvolution
    % Sort the tabulated eccentricities
    tabulatedEccentricityRadiiDegs = sort(deconvolutionModel.center.tabulatedEccentricityRadii);
    
    % Compute interpolation indices and weights
    [interpolationEccIndices, interpolationEccWeights] = computeInterpolationIndices(...
        'center', 'eccentricities', tabulatedEccentricityRadiiDegs, ...
        rfEccRadiusDegs);
    
   
    % Memory allocation
    rgcsNum = size(rfCenterPositionMicrons,1);
    centerVisualCharacteristicRadiiDegs = zeros(rgcsNum,1);
    centerRetinalCharacteristicRadiiDegs = zeros(rgcsNum,1);
    centerVisualGainSensitivity = zeros(rgcsNum,1);
    centerRetinalGainSensitivity = zeros(rgcsNum,1);
    correctionFactors = zeros(rgcsNum,1);
    
    % Use the deconvolutionModel.center to determine the center's VISUAL characteristic radius
    % based on the number of input cones to this cells' RF center, and also
    % the center's visual and retinal gain attenuation factors
    tabulatedRFcenterConeInputsNum = squeeze(deconvolutionModel.center.centerConeInputsNum(1,:));

    
    parfor RGCindex = 1:rgcsNum
        neighboringEccIndices = interpolationEccIndices(RGCindex,:);
        coneInputsIndex = find(tabulatedRFcenterConeInputsNum == rfCenterInputConesNum(RGCindex));
        
        % Weighted (according to the neighboring eccentricities) radiusMin and radiusMax
        visualRadiusMin = sum((deconvolutionModel.center.visualCharacteristicRadiusMin(neighboringEccIndices,coneInputsIndex))' .* interpolationEccWeights(RGCindex,:),2);
        visualRadiusMax = sum((deconvolutionModel.center.visualCharacteristicRadiusMax(neighboringEccIndices,coneInputsIndex))' .* interpolationEccWeights(RGCindex,:),2);
        retinalRadiusMin = sum((deconvolutionModel.center.retinalCharacteristicRadiusMin(neighboringEccIndices,coneInputsIndex))' .* interpolationEccWeights(RGCindex,:),2);
        retinalRadiusMax = sum((deconvolutionModel.center.retinalCharacteristicRadiusMax(neighboringEccIndices,coneInputsIndex))' .* interpolationEccWeights(RGCindex,:),2);
        
        % Mean VISUAL characteristic radius of the center
        centerVisualCharacteristicRadiiDegs(RGCindex) = mean([visualRadiusMin visualRadiusMax]); %visualRadiusMax; %mean([visualRadiusMin visualRadiusMax]);
       
        % Mean RETINAL characteristic radius of the center
        centerRetinalCharacteristicRadiiDegs(RGCindex) = mean([retinalRadiusMin retinalRadiusMax]); % retinalRadiusMax; %mean([retinalRadiusMin retinalRadiusMax]);
       
        % Mean VISUAL gain sensitivity of the center
        centerVisualGainSensitivity(RGCindex)  = sum((deconvolutionModel.center.visualGain(neighboringEccIndices,coneInputsIndex))' .* interpolationEccWeights(RGCindex,:),2);
        
        % Mean RETINAL gain sensitivity of the center
        centerRetinalGainSensitivity(RGCindex) = sum((deconvolutionModel.center.retinalGain(neighboringEccIndices,coneInputsIndex))' .* interpolationEccWeights(RGCindex,:),2);
        
        % Correction factor to account for the fact that cones do not have
        % Gaussian sensitivity profile, but a cylindrical one.
        correctionFactors(RGCindex) = 1 + (deconvolutionModel.correctionFactorForDifferenceBetweenFlatopAndGaussianArea-1) * 1.0/sqrt(rfCenterInputConesNum(RGCindex));
    end
    correctionFactors
    centerVisualCharacteristicRadiiDegs = centerVisualCharacteristicRadiiDegs .* correctionFactors;
    
    % Use the Croner&Kaplan model centerPeakSensitivityFunction() to
    % compute the center VISUAL peak sensitivity from the center's VISUAL
    % characteristic radius computed previously
    centerVisualPeakSensitivities = obj.centerPeakSensitivityFunction(obj.centerPeakSensitivityParams, centerVisualCharacteristicRadiiDegs);

    
    % Compute peak sensitivity boosting factor. This is determined from
    % fitting flat-top Gaussians to the retinal and visual cone activation
    % maps (see CronerKaplanRGCModel.performDeconvolutionAnalysisForRFcenter()).
    % Basically we are boosting the center peak sensitivity by the inverse
    % of the centerVisualGain (which is attenuated due to optical blurring)
    % NOTE. We also multiply by the centerRetinalGain to take into effect any
    % artifacts introduced by the fitting. But maybe we shouldnt be doing
    % this.
    centerPeakSensitivityBoostingFactor = (1 ./ centerVisualGainSensitivity); % .* centerRetinalGainSensitivity;
    
    % Multiply with the corresponding boosting factors 
    centerRetinalPeakSensitivities = centerVisualPeakSensitivities .* centerPeakSensitivityBoostingFactor;
    

    % Having determined the center VISUAL characteristic radius, we use the Croner&Kaplan model center-to-surround ratio function to
    % compute the surround VISUAL characteristic radius 
    surroundVisualCharacteristicRadiiDegs = CronerKaplanRGCModel.surroundRadiusFromCenterRadiusDegs(centerVisualCharacteristicRadiiDegs);

    % Next, we use the Croner&Kaplan model surround to center integrated
    % VISUAL sensitivity ratio to compute the surround VISUAL peak sensitivity
    surroundVisualPeakSensitivities = ...
        CronerKaplanRGCModel.surroundToCenterIntegratedVisualSensitivityRatiosFromEccDegs(rfEccRadiusDegs) .* ...
        centerVisualPeakSensitivities ./ ...
        ((surroundVisualCharacteristicRadiiDegs./centerVisualCharacteristicRadiiDegs).^2);
    
    % In the final step, we compute the surround RETINAL characteristic radius and peak sensitivity 
    % using the deconvolutionModel.surround
    
    surroundRetinalCharacteristicRadiiDegs = zeros(rgcsNum,1);
    surroundRetinalGainSensitivity = zeros(rgcsNum,1);
    surroundVisualGainSensitivity = zeros(rgcsNum,1);
    
    for RGCindex = 1:rgcsNum
        neighboringEccIndices = interpolationEccIndices(RGCindex,:);
        coneInputsIndex = find(tabulatedRFcenterConeInputsNum == rfCenterInputConesNum(RGCindex));
        
        retinalCharacteristicRadiusEstimates = zeros(1,2);
        visualGainSensitivities = zeros(1,2);
        retinalGainSensitivities = zeros(1,2);
        
        for k = 1:numel(neighboringEccIndices)
            % determine interpolation weights for 2 closest surround characteristic radii
            examinedVisualCharacteristicRadii = squeeze(deconvolutionModel.surround.visualCharacteristicRadius(neighboringEccIndices(k),coneInputsIndex,:));
            [interpolationSurroundRadiiIndices, interpolationSurroundRadiiWeights] = computeInterpolationIndices(...
                'surround', 'radii', examinedVisualCharacteristicRadii, surroundVisualCharacteristicRadiiDegs(RGCindex));
            
            examinedRetinalCharacteristicRadii = ...
                squeeze(deconvolutionModel.surround.retinalCharacteristicRadius(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            retinalCharacteristicRadiusEstimates(1,k) = sum(examinedRetinalCharacteristicRadii' .* interpolationSurroundRadiiWeights,2);
            
            examinedVisualGainSensitivities = ...
                squeeze(deconvolutionModel.surround.visualGain(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            visualGainSensitivities(1,k) = sum(examinedVisualGainSensitivities' .* interpolationSurroundRadiiWeights,2);
            
            examinedRetinalGainSensitivities = ...
                squeeze(deconvolutionModel.surround.retinalGain(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            retinalGainSensitivities(1,k) = sum(examinedRetinalGainSensitivities' .* interpolationSurroundRadiiWeights,2);
        end
        
        % Weighted (according to the neighboring eccentricities) estimates
        surroundRetinalCharacteristicRadiiDegs(RGCindex) = sum(retinalCharacteristicRadiusEstimates .* interpolationEccWeights(RGCindex,:),2);
        surroundRetinalGainSensitivity(RGCindex) = sum(retinalGainSensitivities .* interpolationEccWeights(RGCindex,:),2);
        surroundVisualGainSensitivity(RGCindex) = sum(visualGainSensitivities .* interpolationEccWeights(RGCindex,:),2); 
    end
    
    
    % Compute peak sensitivity boosting factor. This is determined from
    % fitting flat-top Gaussians to the retinal and visual cone activation
    % maps (see CronerKaplanRGCModel.performDeconvolutionAnalysisForRFsurround()).
    % Basically we are boosting the center peak sensitivity by the inverse
    % of the centerVisualGain (which is attenuated due to optical blurring)
    % NOTE. We also multiply by the centerRetinalGain to take into effect any
    % artifacts introduced by the fitting. But maybe we shouldnt be doing
    % this.
    surroundPeakSensitivityBoostingFactor = (1 ./ surroundVisualGainSensitivity);% .* surroundRetinalGainSensitivity;

    
    % Multiply with the corresponding boosting factors 
    surroundRetinalPeakSensitivities = surroundVisualPeakSensitivities .* surroundPeakSensitivityBoostingFactor;
    
    % Compute surround radius in retinal microns
    surroundRetinalCharacteristicRadiiMicrons = WatsonRGCModel.sizeDegsToSizeRetinalMicrons(surroundRetinalCharacteristicRadiiDegs, rfEccRadiusDegs);
    
    synthesizedRFParams = struct(...
        'rfEccRadiusDegs', rfEccRadiusDegs, ...                                     % ecc of RGCs within the target patch  - DONE
        'rfCenterPositionMicrons', rfCenterPositionMicrons, ...
        'visual', struct(...                                                        % VISUAL RF properties
            'centerCharacteristicRadiiDegs', centerVisualCharacteristicRadiiDegs, ...             
            'surroundCharacteristicRadiiDegs', surroundVisualCharacteristicRadiiDegs, ...         
            'centerPeakSensitivities', centerVisualPeakSensitivities,...            
            'surroundPeakSensitivities', surroundVisualPeakSensitivities...          
            ), ...
         'retinal', struct(...                                                      % RETINAL RF properties
             'centerCharacteristicRadiiDegs', centerRetinalCharacteristicRadiiDegs, ...          
             'surroundCharacteristicRadiiDegs', surroundRetinalCharacteristicRadiiDegs, ...          
             'surroundCharacteristicRadiiMicrons', surroundRetinalCharacteristicRadiiMicrons, ...
             'centerPeakSensitivities', centerRetinalPeakSensitivities,... 
             'surroundPeakSensitivities', surroundRetinalPeakSensitivities... 
            )...
         ); 
end

function  [interpolationEccIndices, interpolationWeights] = computeInterpolationIndices(...
        subregionName, domainName, tabulatedValues, targetValues)
    
    % Determine linear interpolation indices and interpolation values
        
    targetsNum = numel(targetValues);
    interpolationEccIndices = zeros(targetsNum,2);
    interpolationWeights = zeros(targetsNum,2);
    
    for targetIndex = 1:targetsNum
        
        theRGCeccentricityDegs = targetValues(targetIndex);
        
        % Find the index of the tabulated eccentricity that is greater or equal to the cell's eccentricity
        idxPos = find(tabulatedValues >= theRGCeccentricityDegs);
        if (isempty(idxPos))
            fprintf(2,'Deconvolution data for %s do not extend up to %2.3f %s. Max value: %2.3f.\n', ...
                subregionName, domainName, targetValues(targetIndex), max(tabulatedValues));
            idxPos = length(tabulatedValues);
        end
        
        % Find the index of the tabulated eccentricity that is greater or equal to the cell's eccentricity
        idxNeg = find(tabulatedValues <= theRGCeccentricityDegs);
        if (isempty(idxNeg))
            fprintf(2,'Deconvolution data for %s  do not extend down to %2.3f %s. Min value: %2.3f.\n', ...
                subregionName, domainName, targetValues(targetIndex), min(tabulatedValues));
            idxNeg = 1;
        end
        
        % Intepolation eccentricity indices for this cell
        interpolationEccIndices(targetIndex,:) = [idxNeg(end) idxPos(1)];
        
        % Compute interpolation weights based on the distance of this cells
        % ecc to the 2 intepolation eccentricities
        interpolationEccs = tabulatedValues(interpolationEccIndices(targetIndex,:));
        interpolationEccRange = abs(diff(interpolationEccs));
        
        if (interpolationEccIndices(targetIndex,1) == interpolationEccIndices(targetIndex,2))
            interpolationWeights(targetIndex,:) = [0.5 0.5];
        else 
            eccDiffs = abs(interpolationEccs - theRGCeccentricityDegs);
            % Interpolation weights
            interpolationWeights(targetIndex,:) = [eccDiffs(2) eccDiffs(1)]/interpolationEccRange;
        end
        
        
%         fprintf('interpolation: cell at %2.2f, below/above: %2.2f, %2.2f: weights: (%2.2f,%2.2f)  \n', ...
%             theRGCeccentricityDegs, ...
%             tabulatedValues(interpolationEccIndices(targetIndex,1)), ...
%             tabulatedValues(interpolationEccIndices(targetIndex,2)), ...
%             interpolationWeights(targetIndex,1), interpolationWeights(targetIndex,2));
    end
end