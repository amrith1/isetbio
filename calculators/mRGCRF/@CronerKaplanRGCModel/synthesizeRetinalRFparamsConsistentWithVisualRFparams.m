function synthesizedRFParams = synthesizeRetinalRFparamsConsistentWithVisualRFparams(obj, ...
    rfCenterInputConesNum, rfCenterPositionMicrons, deconvolutionOpticsParams)
% Returns a struct with corresponding retinal <-> visual parameter of
% center/surround characteristic radii & peak sensitivities. These
% are computed from the retinal RF center size and position as determined
% by the connectivity matrix between the cone mosaic and the mRGC RF
% mosaic. The correspondence between retinal <-> visual parameters is build
% based on a deconvolution model (computed based on the various deconvolution files
% which are generated via obj.generatePolansOpticsDeconvolutionFiles()).
% 
    % Validate deconvolutionOpticsParams
    obj.validateDeconvolutionOpticsParams(deconvolutionOpticsParams);
    
    % Compute the deconvolution model. This relies on the various
    % ecc_-%2.1f_deconvolutions_refractionError_%2.2fD.mat data files that
    % are generated by obj.generatePolansOpticsDeconvolutionFiles(deconvolutionOpticsParams)
    % See performPSFConvoComputations

    deconvolutionModel = obj.computeDeconvolutionModel(deconvolutionOpticsParams);

    % Convert RF center positions in retinal microns to visual degs
    rfEccRadiusMicrons = (sqrt(sum(rfCenterPositionMicrons.^2,2.0)));
    rfEccRadiusDegs = WatsonRGCModel.rhoMMsToDegs(rfEccRadiusMicrons/1000.0);
    
    % Find interpolation weights for the center deconvolution
    % Sort the tabulated eccentricities
    tabulatedEccentricityRadiiDegs = sort(deconvolutionModel.center.tabulatedEccentricityRadii);
    
    % Compute interpolation indices and weights
    [interpolationEccIndices, interpolationEccWeights] = computeInterpolationIndices(...
        'center', 'eccentricities', tabulatedEccentricityRadiiDegs, ...
        rfEccRadiusDegs);
    
    % Memory allocation
    rgcsNum = size(rfCenterPositionMicrons,1);
    centerVisualCharacteristicRadiiDegs = zeros(rgcsNum,1);
    centerVisualPeakSensitivityAttenuation = zeros(rgcsNum,1);
    
    % Use the deconvolutionModel.center to determine the center's VISUAL characteristic radius
    % based on the number of input cones to this cells' RF center, and also
    % the center's visual peak sensitivity attenuation factor
    tabulatedRFcenterConeInputsNum = squeeze(deconvolutionModel.center.centerConeInputsNum(1,:));
    
    
    parfor RGCindex = 1:rgcsNum
        neighboringEccIndices = interpolationEccIndices(RGCindex,:);
        coneInputsIndex = find(tabulatedRFcenterConeInputsNum == rfCenterInputConesNum(RGCindex));
        assert(~isempty(coneInputsIndex), 'Center subregion deconvolution data for %d cone inputs in the center have not been computed.', rfCenterInputConesNum(RGCindex));
        
        characteristicRadiusDegsAtNeihboringEccs = deconvolutionModel.center.characteristicRadiusDegs(neighboringEccIndices,coneInputsIndex);
        peakSensitivitiesAtNeihboringEccs = deconvolutionModel.center.peakSensitivity(neighboringEccIndices,coneInputsIndex);
        weightsOfNeighboringEccs = interpolationEccWeights(RGCindex,:);
        
        centerVisualCharacteristicRadiiDegs(RGCindex) = sum(characteristicRadiusDegsAtNeihboringEccs' .* weightsOfNeighboringEccs,2);
        centerVisualPeakSensitivityAttenuation(RGCindex) = sum(peakSensitivitiesAtNeihboringEccs' .* weightsOfNeighboringEccs,2);
    end
    
    % Use the Croner&Kaplan model centerPeakSensitivityFunction() to
    % compute the center VISUAL peak sensitivity from the center's VISUAL
    % characteristic radius 
    centerVisualPeakSensitivities = obj.centerPeakSensitivityFunction(obj.centerPeakSensitivityParams, centerVisualCharacteristicRadiiDegs);

    % Compute peak sensitivity boosting factor based on the results of deconvolution
    centerPeakSensitivityBoostingFactor = (1 ./ centerVisualPeakSensitivityAttenuation);
    
    % Multiply the visual peak sensitivity with the peak sensitivity boosting factor
    % to obtain the equivalent retinal peak sensitivity 
    centerRetinalPeakSensitivities = centerVisualPeakSensitivities .* centerPeakSensitivityBoostingFactor;
    
    % Having determined the center VISUAL characteristic radius, we use the Croner&Kaplan model center-to-surround ratio function to
    % compute the surround VISUAL characteristic radius 
    surroundVisualCharacteristicRadiiDegs = CronerKaplanRGCModel.surroundRadiusFromCenterRadiusDegs(centerVisualCharacteristicRadiiDegs);

    % Next, we use the Croner&Kaplan model surround to center integrated
    % VISUAL sensitivity ratio to compute the surround VISUAL peak sensitivity
    surroundVisualPeakSensitivities = ...
        CronerKaplanRGCModel.surroundToCenterIntegratedVisualSensitivityRatiosFromEccDegs(rfEccRadiusDegs) .* ...
        centerVisualPeakSensitivities ./ ...
        ((surroundVisualCharacteristicRadiiDegs./centerVisualCharacteristicRadiiDegs).^2);
    

    % In the final step, we compute the surround RETINAL characteristic radius and peak sensitivity 
    % using the deconvolutionModel.surround
    
    surroundRetinalCharacteristicRadiiDegs = zeros(rgcsNum,1);
    surroundVisualGainSensitivity = zeros(rgcsNum,1);
    
    parfor RGCindex = 1:rgcsNum
        neighboringEccIndices = interpolationEccIndices(RGCindex,:);
        coneInputsIndex = find(tabulatedRFcenterConeInputsNum == rfCenterInputConesNum(RGCindex));
        
        retinalCharacteristicRadiusEstimates = zeros(1,2);
        visualGainSensitivities = zeros(1,2);
        
        for k = 1:numel(neighboringEccIndices)
            % determine interpolation weights for 2 closest surround characteristic radii
            nonNanIndices = find(~isnan(squeeze(deconvolutionModel.surround.characteristicRadiusDegs(neighboringEccIndices(k),coneInputsIndex,:))));
            
            examinedVisualCharacteristicRadii = squeeze(deconvolutionModel.surround.characteristicRadiusDegs(neighboringEccIndices(k),coneInputsIndex,nonNanIndices));
            [interpolationSurroundRadiiIndices, interpolationSurroundRadiiWeights] = computeInterpolationIndices(...
                'surround', 'radii', examinedVisualCharacteristicRadii, surroundVisualCharacteristicRadiiDegs(RGCindex));
            
            examinedRetinalCharacteristicRadii = ...
                squeeze(deconvolutionModel.surround.nominalSurroundRetinalCharacteristicRadii(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            retinalCharacteristicRadiusEstimates(1,k) = sum(examinedRetinalCharacteristicRadii' .* interpolationSurroundRadiiWeights,2);
            
            examinedVisualPeakSensitivities = ...
                squeeze(deconvolutionModel.surround.peakSensitivity(neighboringEccIndices(k),coneInputsIndex,interpolationSurroundRadiiIndices));
            visualGainSensitivities(1,k) = sum(examinedVisualPeakSensitivities' .* interpolationSurroundRadiiWeights,2);
        end
        
        % Weighted (according to the neighboring eccentricities) estimates
        surroundRetinalCharacteristicRadiiDegs(RGCindex) = sum(retinalCharacteristicRadiusEstimates .* interpolationEccWeights(RGCindex,:),2);
        surroundVisualGainSensitivity(RGCindex) = sum(visualGainSensitivities .* interpolationEccWeights(RGCindex,:),2); 
    end
    
    % Compute peak sensitivity boosting factor based on the results of deconvolution
    surroundPeakSensitivityBoostingFactor = (1 ./ surroundVisualGainSensitivity);

    % Multiply the visual peak sensitivity with the peak sensitivity boosting factor
    % to obtain the equivalent retinal peak sensitivity 
    surroundRetinalPeakSensitivities = surroundVisualPeakSensitivities .* surroundPeakSensitivityBoostingFactor;
    
    % Compute surround radius in retinal microns
    surroundRetinalCharacteristicRadiiMicrons = WatsonRGCModel.sizeDegsToSizeRetinalMicrons(surroundRetinalCharacteristicRadiiDegs, rfEccRadiusDegs);
    
    
    synthesizedRFParams = struct(...
        'rfEccRadiusDegs', rfEccRadiusDegs, ...                                     % ecc of RGCs within the target patch  - DONE
        'rfCenterPositionMicrons', rfCenterPositionMicrons, ...
        'visual', struct(...                                                        % VISUAL RF properties
            'centerCharacteristicRadiiDegs', centerVisualCharacteristicRadiiDegs, ...             
            'surroundCharacteristicRadiiDegs', surroundVisualCharacteristicRadiiDegs, ...         
            'centerPeakSensitivities', centerVisualPeakSensitivities,...            
            'surroundPeakSensitivities', surroundVisualPeakSensitivities...          
            ), ...
         'retinal', struct(...                                                      % RETINAL RF properties  
             'centerCharacteristicRadiiDegs', nan(size(surroundRetinalCharacteristicRadiiDegs)), ...  % there is no retinal center characteristic radius
             'surroundCharacteristicRadiiDegs', surroundRetinalCharacteristicRadiiDegs, ...          
             'surroundCharacteristicRadiiMicrons', surroundRetinalCharacteristicRadiiMicrons, ...
             'centerPeakSensitivities', centerRetinalPeakSensitivities,... 
             'surroundPeakSensitivities', surroundRetinalPeakSensitivities... 
            )...
         );
end

function  [interpolationEccIndices, interpolationWeights] = computeInterpolationIndices(...
        subregionName, domainName, tabulatedValues, targetValues)
    
    % Determine linear interpolation indices and interpolation values
        
    targetsNum = numel(targetValues);
    interpolationEccIndices = zeros(targetsNum,2);
    interpolationWeights = zeros(targetsNum,2);
    
    for targetIndex = 1:targetsNum
        
        theRGCeccentricityDegs = targetValues(targetIndex);
        
        % Find the index of the tabulated eccentricity that is greater or equal to the cell's eccentricity
        idxPos = find(tabulatedValues >= theRGCeccentricityDegs);
        if (isempty(idxPos))
            fprintf(2,'Deconvolution data for %s do not extend up to %2.3f %s. Max value: %2.3f.\n', ...
                subregionName,  targetValues(targetIndex), domainName, max(tabulatedValues));
            idxPos = length(tabulatedValues);
        end
        
        % Find the index of the tabulated eccentricity that is greater or equal to the cell's eccentricity
        idxNeg = find(tabulatedValues <= theRGCeccentricityDegs);
        if (isempty(idxNeg))
            fprintf(2,'Deconvolution data for %s  do not extend down to %2.3f %s. Min value: %2.3f.\n', ...
                subregionName, targetValues(targetIndex), domainName, min(tabulatedValues));
            idxNeg = 1;
        end
        
        % Intepolation eccentricity indices for this cell
        interpolationEccIndices(targetIndex,:) = [idxNeg(end) idxPos(1)];
        
        % Compute interpolation weights based on the distance of this cells
        % ecc to the 2 intepolation eccentricities
        interpolationEccs = tabulatedValues(interpolationEccIndices(targetIndex,:));
        interpolationEccRange = abs(diff(interpolationEccs));
        
        if (interpolationEccIndices(targetIndex,1) == interpolationEccIndices(targetIndex,2))
            interpolationWeights(targetIndex,:) = [0.5 0.5];
        else 
            eccDiffs = abs(interpolationEccs - theRGCeccentricityDegs);
            % Interpolation weights
            interpolationWeights(targetIndex,:) = [eccDiffs(2) eccDiffs(1)]/interpolationEccRange;
        end
        
        
%         fprintf('interpolation: cell at %2.2f, below/above: %2.2f, %2.2f: weights: (%2.2f,%2.2f)  \n', ...
%             theRGCeccentricityDegs, ...
%             tabulatedValues(interpolationEccIndices(targetIndex,1)), ...
%             tabulatedValues(interpolationEccIndices(targetIndex,2)), ...
%             interpolationWeights(targetIndex,1), interpolationWeights(targetIndex,2));
    end
end