function coneMosaic(app)

    % Generate cone mosaic with new params
    app.components.coneMosaic = cMosaic(...
        'whichEye', app.coneMosaicParams.whichEye, ...
        'sizeDegs', app.coneMosaicParams.sizeDegs, ...
        'eccentricityDegs', app.coneMosaicParams.eccentricityDegs);
    
    % Reset view limits
    app.coneMosaicViewXLimsDegs = app.coneMosaicParams.eccentricityDegs(1) + 0.5*app.coneMosaicParams.sizeDegs(1)*[-1 1];
    app.coneMosaicViewYLimsDegs = app.coneMosaicParams.eccentricityDegs(2) + 0.5*app.coneMosaicParams.sizeDegs(2)*[-1 1];
    
    if (~isempty(app.components.coneMosaic.micronsPerDegreeApproximation))
       app.coneMosaicViewXLimsMicrons = app.coneMosaicViewXLimsDegs * app.components.coneMosaic.micronsPerDegreeApproximation; 
       app.coneMosaicViewYLimsMicrons = app.coneMosaicViewYLimsDegs * app.components.coneMosaic.micronsPerDegreeApproximation;
    else
        for k = 1:2
            app.coneMosaicViewXLimsMicrons(k) = 1e3 * RGCmodels.Watson.convert.rhoDegsToMMs(app.coneMosaicViewXLimsDegs(k));
            app.coneMosaicViewYLimsMicrons(k) = 1e3 * RGCmodels.Watson.convert.rhoDegsToMMs(app.coneMosaicViewYLimsDegs(k));
        end
    end
            
    % Generate outlines for central cones (used when plotting the PSF)
    if (~isempty(app.components.coneMosaic.coneRFpositionsDegs))
        conePos = bsxfun(@minus, app.components.coneMosaic.coneRFpositionsDegs, app.components.coneMosaic.eccentricityDegs);
        coneEccArcMin = 60*sqrt(sum(conePos.^2,2));
        [~, idx] = sort(coneEccArcMin);
        centralCone = idx(1);
        conePos = bsxfun(@minus, app.components.coneMosaic.coneRFpositionsDegs, app.components.coneMosaic.coneRFpositionsDegs(centralCone,:));
        coneEccArcMin = 60*sqrt(sum(conePos.^2,2));
        [~, idx] = sort(coneEccArcMin);

        % Extract the centralConeOutlinesArcMin 
        for k = 1:app.centralConeOutlinesNum
            if (k <= numel(idx))
                coneIndex = idx(k);
                radius = 0.5*app.components.coneMosaic.coneRFspacingsDegs(coneIndex)*60*app.components.coneMosaic.coneApertureToDiameterRatio;
                app.centralConeOutlinesArcMin(k,1,:) = (conePos(coneIndex,1)-conePos(centralCone,1))*60 + radius * cosd(0:5:360);
                app.centralConeOutlinesArcMin(k,2,:) = (conePos(coneIndex,2)-conePos(centralCone,2))*60 + radius * sind(0:5:360);
            else
                app.centralConeOutlinesArcMin(k,1,:) = nan;
                app.centralConeOutlinesArcMin(k,2,:) = nan;
            end
        end
    else
        for k = 1:app.centralConeOutlinesNum
            app.centralConeOutlinesArcMin(k,1,:) = nan;
            app.centralConeOutlinesArcMin(k,2,:) = nan;
        end
    end
        
    
    
    
%     , ...
%         'coneDensities', app.mosaicConeDensities, ...
%         'tritanopicRadiusDegs', app.mosaicTritanopicRadiusDegs, ...
%         'wave', app.wavelengthMinValue : app.wavelengthStepSize: app.wavelengthMaxValue, ...
%         'integrationTime', app.mosaicIntegrationTimeMseconds/1000, ...
%         'eccVaryingConeAperture', app.mosaicEccVaryingConeAperture, ...
%         'eccVaryingOuterSegmentLength', app.mosaicEccVaryingOuterSegmentLength, ...
%         'eccVaryingConeBlur', app.mosaicEccVaryingConeBlur, ...
%         'eccVaryingMacularPigmentDensity', app.mosaicEccVaryingMacularPigmentDensity, ...
%         'eccVaryingMacularPigmentDensityDynamic', false ...


    % Visualize the cone mosaic
    CSFGeneratorApp.render.coneMosaicView(app, 'update');
    
    % Set the microns-per-deg field
    app.visualFieldMagnificationFactorEditField.Value = app.components.coneMosaic.micronsPerDegree;   

    % Update status for 'cone mosaic'
    app.statusMessages('stimulus')  = struct(...
        'text', statusReportText, ...
        'fontColor', statusFontColor, ...
        'backgroundColor', statusBackgroundColor, ...
        'fontWeight', statusFontWeight);
    
    % Render the status on the  status field
    app.render.statusField(app,'B', app.statusMessages('cone mosaic')); 
end

